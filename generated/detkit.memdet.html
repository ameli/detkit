


<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<meta property="og:title" content="memdet" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://ameli.github.io/generated/detkit.memdet.html" />
<meta property="og:site_name" content="DetKit" />
<meta property="og:image" content="https://raw.githubusercontent.com/ameli/detkit/main/docs/source/_static/images/icons/logo-detkit-light.svg" />
<meta property="og:image:alt" content="DetKit" />
<meta property="og:title" content="DetKit">
<meta property="og:description" content="DetKit is a python package to compute some common functions involving determinant of matrices used in machine learning.">

    <title>memdet &#8212; detkit Manual</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "auto";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom-pydata.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.5ea377869091fd0449014c60fc090103.min.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/toggleprompt.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/js/custom-pydata.js"></script>
    <script src="../_static/design-tabs.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}, "tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/custom-pydata.css"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="detkit.FitLogdet" href="detkit.FitLogdet.html" />
    <link rel="prev" title="logpdet" href="detkit.logpdet.html" />
    <script defer data-domain="docs.scipy.org" src="https://views.scientific-python.org/js/script.js"></script>

    <!-- My custom JS -->
    <script type="text/javascript" src="../_static/js/custom-pydata.js"></script>

    <!-- Syntax highlighting for BibTex code blocks -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-solarizedlight.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs-bibtex@2.0.1/prism-bibtex.min.js"></script>

    
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="en">

  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="auto">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../index.html">
  
  
  
  
    <img src="../_static/images/icons/logo-detkit-light.png" class="logo__image only-light" alt="Logo image">
    <img src="../_static/images/icons/logo-detkit-dark.png" class="logo__image only-dark" alt="Logo image">
  
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../install/install.html">
  Install
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../docker.html">
  Docker
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="../api.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../benchmark.html">
  Benchmark
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/ameli/detkit" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://pypi.org/project/detkit/" rel="noopener" target="_blank" title="PyPI"><span><i class="fab fa-python"></i></span>
            <label class="sr-only">PyPI</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://anaconda.org/s-ameli/detkit" rel="noopener" target="_blank" title="Anaconda Cloud"><span><i class="fa fa-circle-notch"></i></span>
            <label class="sr-only">Anaconda Cloud</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://hub.docker.com/r/sameli/detkit" rel="noopener" target="_blank" title="Docker Hub"><span><i class="fab fa-docker"></i></span>
            <label class="sr-only">Docker Hub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://mybinder.org/v2/gh/ameli/detkit/HEAD?filepath=notebooks%2FInterpolateTraceOfInverse.ipynb" rel="noopener" target="_blank" title="Lanuch Jupyter on Binder"><span><i class="fas fa-book-open"></i></span>
            <label class="sr-only">Lanuch Jupyter on Binder</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
    <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Matrix Determinant
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.logdet.html">
   logdet
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.loggdet.html">
   loggdet
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.logpdet.html">
   logpdet
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   memdet
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Profiling
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.FitLogdet.html">
   detkit.FitLogdet
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Supplementary
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.orthogonalize.html">
   orthogonalize
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.ortho_complement.html">
   ortho_complement
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.lu_factor.html">
   lu_factor
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.ldl_factor.html">
   ldl_factor
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.cho_factor.html">
   cho_factor
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Solving Linear Systems
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.lu_solve.html">
   lu_solve
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.ldl_solve.html">
   ldl_solve
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.cho_solve.html">
   cho_solve
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.solve_triangular.html">
   solve_triangular
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  BLAS Operations
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.matmul.html">
   matmul
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Datasets
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.electrocardiogram.html">
   electrocardiogram
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.covariance_matrix.html">
   covariance_matrix
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.design_matrix.html">
   design_matrix
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Profiling
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.Memory.html">
   detkit.Memory
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.Disk.html">
   detkit.Disk
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.Profile.html">
   detkit.Profile
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Profiling Utilities
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.get_config.html">
   get_config
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.check_perf_support.html">
   check_perf_support
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.get_instructions_per_flop.html">
   get_instructions_per_flop
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.get_processor_name.html">
   get_processor_name
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.human_readable_time.html">
   human_readable_time
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.human_readable_mem.html">
   human_readable_mem
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Profiling Utilities
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="detkit.InstructionsCounter.html">
   detkit.InstructionsCounter
  </a>
 </li>
</ul>

    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
    
    <div class="toc-item">
      
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#detkit.memdet">
   <code class="docutils literal notranslate">
    <span class="pre">
     memdet()
    </span>
   </code>
  </a>
 </li>
</ul>

</nav>
    </div>
    
    <div class="toc-item">
      

<div class="tocsection editthispage">
    <a href="https://github.com/ameli/detkit/edit/main/docs/source/generated/detkit.memdet.rst">
        <i class="fas fa-pencil-alt"></i> Edit this page
    </a>
</div>

    </div>
    
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <section id="memdet">
<h1>memdet<a class="headerlink" href="#memdet" title="Permalink to this heading">#</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="detkit.memdet">
<span class="sig-prename descclassname"><span class="pre">detkit.</span></span><span class="sig-name descname"><span class="pre">memdet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_mem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_blocks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gen'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">triangle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mixed_precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'float64'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel_io</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scratch_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#detkit.memdet" title="Permalink to this definition">#</a></dt>
<dd><p>Compute log-determinant under memory constraint.</p>
<p>This function computes the determinant of the matrix</p>
<div class="math notranslate nohighlight">
\[\mathbf{M} = t \mathbf{A} + \mathbf{D}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> is a square matrix, <span class="math notranslate nohighlight">\(t\)</span> is a real scalar,
and <span class="math notranslate nohighlight">\(\mathbf{D}\)</span> is a diagonal matrix.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>A</strong><span class="classifier">numpy.ndarray, numpy.memmap, zarr.Array, dask.array,            tensotstore.array</span></dt><dd><p>Square dense matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>. This matrix can be given
either as an array that is already loaded on the memory (such as
<code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>), or if it cannot fit on the memory capacity, it can
be provided as a memory map on disk, such as Numpy’s <code class="docutils literal notranslate"><span class="pre">memmap</span></code>, Zarr,
Dask, or TensorStore array formats.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float, default=1.0</span></dt><dd><p>Scalar <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>d</strong><span class="classifier">float, numpy.array, default=0.0</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">d</span></code> is a scalar, the diagonal matrix <span class="math notranslate nohighlight">\(\mathbf{D}\)</span> is
assumed to be <span class="math notranslate nohighlight">\(\mathbf{D} = d \mathbf{I}\)</span> where
<span class="math notranslate nohighlight">\(\mathbf{I}\)</span> is the identity matrix. If <code class="docutils literal notranslate"><span class="pre">d</span></code> is given as an
array <span class="math notranslate nohighlight">\(\boldsymbol{d}\)</span> of size <span class="math notranslate nohighlight">\(n\)</span>, the diagonal matrix
<span class="math notranslate nohighlight">\(\mathbf{D}\)</span> is constructed by
<span class="math notranslate nohighlight">\(\mathbf{D} = \mathrm{diag}(\boldsymbol{d})\)</span>.</p>
</dd>
<dt><strong>max_mem</strong><span class="classifier">float or str, default= <code class="docutils literal notranslate"><span class="pre">float('inf')</span></code></span></dt><dd><p>The maximum memory allowed to be allocated during the computation.
This can be specified as an integer representing the number of bytes,
or as a string such as <code class="docutils literal notranslate"><span class="pre">16.2GB</span></code> (a number immediately followed by
the unit of memory such as <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">KB</span></code>, <code class="docutils literal notranslate"><span class="pre">MB</span></code>, <code class="docutils literal notranslate"><span class="pre">GB</span></code>, <code class="docutils literal notranslate"><span class="pre">TB</span></code>, etc).</p>
<p>The default value of <code class="docutils literal notranslate"><span class="pre">float('inf')</span></code> indicates infinite amount of
memory is available, hence, no memory is constrained. This case falls
back to conventional computation of log-determinant on memory without
creation of any scratchpad space on disk.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To constrain memory, you can either set <code class="docutils literal notranslate"><span class="pre">max_mem</span></code> or directly set
the number of matrix blocks (see <code class="docutils literal notranslate"><span class="pre">num_blocks</span></code> option). If
<code class="docutils literal notranslate"><span class="pre">max_mem</span></code> is set, <code class="docutils literal notranslate"><span class="pre">num_block</span></code> option is ignored.</p>
</div>
</dd>
<dt><strong>num_blocks</strong><span class="classifier">int, default=1</span></dt><dd><p>Number of memory blocks along rows and columns. This is used when
the whole matrix cannot be loaded on the memory, rather, smaller
blocks of the matrix are loaded on the memory.</p>
<ul class="simple">
<li><p>If <cite>=1</cite>:  the whole matrix is loaded to memory as one block. No
scratchpad disk space is needed as all data is on memory.</p></li>
<li><p>If <cite>=2</cite>:  matrix is decomposed to 2 by 2 memory blocks (four blocks),
but three of these blocks will be loaded concurrently to memory. No
scratchpad disk space is needed.</p></li>
<li><p>If <cite>&gt;2</cite>: matrix is decomposed to a grid of (<code class="docutils literal notranslate"><span class="pre">num_blocks</span></code>,
<code class="docutils literal notranslate"><span class="pre">num_blocks</span></code>) blocks, but only <cite>4</cite> of these blocks will be loaded
concurrently. Scratchpad disk space will be created (see
<code class="docutils literal notranslate"><span class="pre">scratch_dir</span></code> option).</p></li>
</ul>
<p>The number of blocks  may or may not be a divisor of the matrix size.
If the number of blocks is not a divisor of the matrix size, the blocks
on the last row-block and column-block will have smaller size.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To constrain memory, you can either set <code class="docutils literal notranslate"><span class="pre">num_blocks</span></code> or directly
set the amount of memory limit (see <code class="docutils literal notranslate"><span class="pre">max_mem</span></code> option). If
<code class="docutils literal notranslate"><span class="pre">max_mem</span></code> is set, the given <code class="docutils literal notranslate"><span class="pre">num_block</span></code> option by the user is
ignored, and instead computed automatically.</p>
</div>
</dd>
<dt><strong>triangle</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">'l'</span></code>, <code class="docutils literal notranslate"><span class="pre">'u'</span></code>, or None, default=None</span></dt><dd><p>When the  matrix is symmetric, this option indicates whether the full
matrix is stored or only a triangular part of the matrix is given:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'l'</span></code>: assumes the lower-triangular part of the matrix is given.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'u'</span></code>: assumes the upper-triangular part of the matrix is given.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: indicates full matrix is given.</p></li>
</ul>
</dd>
<dt><strong>assume</strong><span class="classifier">str {<code class="docutils literal notranslate"><span class="pre">'gen'</span></code>, <code class="docutils literal notranslate"><span class="pre">'sym'</span></code>, <code class="docutils literal notranslate"><span class="pre">'spd'</span></code>}, default= <code class="docutils literal notranslate"><span class="pre">'gen'</span></code></span></dt><dd><p>Assumption on the input matrix <cite>A</cite>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'gen'</span></code>: generic square matrix</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'sym'</span></code>: symmetric matrix</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'spd'</span></code>: symmetric positive-definite matrix</p></li>
</ul>
<p>The assumption on the matrix is not checked.</p>
</dd>
<dt><strong>mixed_precision</strong><span class="classifier">str {<code class="docutils literal notranslate"><span class="pre">'float32'</span></code>, <code class="docutils literal notranslate"><span class="pre">'float64'</span></code>}, or numpy.dtype,            default= <code class="docutils literal notranslate"><span class="pre">'float64'</span></code></span></dt><dd><p>The precision at which the computations are performed. This may be
different than the data type of the input matrix. It is recommended
to set a precision equal or higher than the <em>dtype</em> of the input
matrix. For instance, if the input matrix has <code class="docutils literal notranslate"><span class="pre">float32</span></code> data type,
you may set this option to <code class="docutils literal notranslate"><span class="pre">float64</span></code>.</p>
</dd>
<dt><strong>parallel_io</strong><span class="classifier">str {<code class="docutils literal notranslate"><span class="pre">'multiproc'</span></code>, <code class="docutils literal notranslate"><span class="pre">'dask'</span></code>, <code class="docutils literal notranslate"><span class="pre">'tensorstore'</span></code>} or            None, default=None</span></dt><dd><p>Parallel data transfer (load and store operations of each block) from
memory to scratchpad on the disk and vice-versa:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'multiproc'</span></code>: utilizes Python’s built-in multiprocessing.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'dask'</span></code>: utilizes Dask’s multiprocessing. For this to work,
the package <a class="reference external" href="https://www.dask.org/">dask</a> should be installed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'tensorstore'</span></code>: utilizes TensorStore’s multiprocessing. For this
to work, the packages
<a class="reference external" href="https://google.github.io/tensorstore/">tensorstore</a> and
<a class="reference external" href="https://zarr.readthedocs.io/">zarr</a> should be installed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: no parallel processing is performed. All data transfer is
performed on a single CPU thread.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The option <code class="docutils literal notranslate"><span class="pre">'tensorstore'</span></code> can only be used when the input matrix
<cite>A</cite> is a <cite>zarr</cite> array. See <a class="reference external" href="https://zarr.readthedocs.io/">zarr</a>
package.</p>
</div>
</dd>
<dt><strong>scratch_dir</strong><span class="classifier">str, default=None</span></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">num_blocks</span></code> is greater than <cite>2</cite>, the computations are performed
on a scratchpad space on disk. This option determines the directory
where memdet should create a temporary scratch file. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
default OS’s tmp directory will be used. For instance, in UNIX, this is
almost always <code class="docutils literal notranslate"><span class="pre">'/tmp'</span></code> directory.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This directory should have enough space as much as the size of the
input matrix (or half of the input matrix size if <code class="docutils literal notranslate"><span class="pre">triangle</span></code>
option is set).</p>
</div>
</dd>
<dt><strong>overwrite</strong><span class="classifier">boolean, default=False</span></dt><dd><p>Uses the input matrix storage for intermediate computations.
This will overwrite the input matrix.</p>
</dd>
<dt><strong>return_info</strong><span class="classifier">bool, default=False</span></dt><dd><p>Returns a dictionary containing profiling information such as wall and
process times, memory allocation, disk usage, etc. See <code class="docutils literal notranslate"><span class="pre">info</span></code>
variable in the return section below.</p>
</dd>
<dt><strong>check</strong><span class="classifier">bool, default=False</span></dt><dd><p>If <cite>True</cite>, it checks for <code class="docutils literal notranslate"><span class="pre">inf</span></code> and <code class="docutils literal notranslate"><span class="pre">nan</span></code> values in the matrix.</p>
</dd>
<dt><strong>flops</strong><span class="classifier">boolean, default=False</span></dt><dd><p>if <cite>True</cite>, FLOP count will be included in <code class="docutils literal notranslate"><span class="pre">info</span></code> output under
<code class="docutils literal notranslate"><span class="pre">info['process']['flops']</span></code>. This option should be used together with
setting <code class="docutils literal notranslate"><span class="pre">return_info=True</span></code>.  To use this option, Perf Tool on your
machine should be installed and proper permission should be granted
(see <a class="reference internal" href="../install/dependencies.html#perf-tool"><span class="std std-ref">Perf Tool</span></a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This option is for Linux operating system only.</p>
</div>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, default=False</span></dt><dd><p>Prints verbose output during computation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ld</strong><span class="classifier">float</span></dt><dd><p><span class="math notranslate nohighlight">\(\mathrm{logabsdet}(\mathbf{M})\)</span>, which is the natural
logarithm of the absolute value of the determinant of the input matrix.</p>
</dd>
<dt><strong>sign</strong><span class="classifier">int</span></dt><dd><p>Sign of determinant, <span class="math notranslate nohighlight">\(\mathrm{sign} (\vert
\mathrm{det}(\mathbf{B}) \vert)\)</span>.</p>
</dd>
<dt><strong>diag</strong><span class="classifier">numpy.array</span></dt><dd><p>A one-dimensional array of the size of the number rows (or columns) of
the matrix, containing the diagonal elements of the matrix
decomposition as follows:</p>
<ul class="simple">
<li><p>For genetic matrix (when <code class="docutils literal notranslate"><span class="pre">assume='gen'</span></code>), this is the diagonal
entries of the matrix <span class="math notranslate nohighlight">\(\mathbf{U}\)</span> in the LU decomposition
<span class="math notranslate nohighlight">\(\mathbf{P} \mathbf{M} = \mathbf{L} \mathbf{U}\)</span>.</p></li>
<li><p>For symmetric matrix (when <code class="docutils literal notranslate"><span class="pre">assume='sym'</span></code>), this is the diagonal
entries of the matrix <span class="math notranslate nohighlight">\(\mathbf{D}\)</span> in the LDL decomposition
<span class="math notranslate nohighlight">\(\mathbf{P} \mathbf{M} = \mathbf{U}^{\intercal}
\mathbf{D} \mathbf{U}\)</span> where <span class="math notranslate nohighlight">\(\mathbf{U}\)</span> is
upper-triangular.</p></li>
<li><p>For symmetric positive-definite matrix (when <code class="docutils literal notranslate"><span class="pre">assume='spd'</span></code>), this
is the diagonal entries of the matrix <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> in the
Cholesky decomposition <span class="math notranslate nohighlight">\(\mathbf{M} = \mathbf{U}^{\intercal}
\mathbf{U}\)</span> where <span class="math notranslate nohighlight">\(\mathbf{U}\)</span> is upper-triangular.</p></li>
</ul>
</dd>
<dt><strong>perm</strong><span class="classifier">numpy.array</span></dt><dd><p>A one-dimensional array of the size of number of rows (or columns) of
the matrix, containing the row (or column) permutations during the
determinant computations, representing the matrix <span class="math notranslate nohighlight">\(\mathbf{P}\)</span>
given above.  See <em>Notes</em> and <em>Examples</em> below on how to interpret this
array.</p>
</dd>
<dt>if <code class="docutils literal notranslate"><span class="pre">return_info=True</span></code>:</dt><dd><dl class="simple">
<dt>info<span class="classifier">dict</span></dt><dd><p>A dictionary containing the following key-values:</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">'matrix'</span></code>: info about input matrix</dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'dtype'</span></code>: the data type of the input matrix.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'matrix_shape'</span></code>: shape of the input matrix.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'triangle'</span></code>: in case of symmetric matrix, whether upper
or lower triangle part of matrix is given (based on
<code class="docutils literal notranslate"><span class="pre">triangle</span></code> option).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'assume'</span></code>: whether matrix is generic, symmetric, or
symmetric and positive-definite (based on <code class="docutils literal notranslate"><span class="pre">assume</span></code> option).</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">'process'</span></code>: info about the computation process and profiling</dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'processor'</span></code>: name of the CPU processor</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'tot_wall_time'</span></code>: total wall time of the process.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'tot_proc_time'</span></code>: total process time of all CPU threads
combined.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'load_wall_time'</span></code>: wall time for only the load operation,
which is the data transfer from disk to memory. This is
relevant only if scratchpad space was used during the
computation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'load_proc_time'</span></code>: process time of all CPU threads for
only the load operation, which is the data transfer from disk
to memory. This is relevant only if scratchpad space was
used during the computation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'store_wall_time'</span></code>: wall time for only the store
operation, which is the data transfer from memory to disk.
This is relevant only if scratchpad space was used during the
computation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'store_proc_time'</span></code>: process time of all CPU threads for
only the store operation, which is the data transfer from
memory to disk. This is relevant only if scratchpad space was
used during the computation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'hw_inst_count'</span></code>: hardware instruction counts.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'flops'</span></code>: FLOPs obtained from hardware instruction counts.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'inst_per_flop'</span></code>: Hardware instructions per FLOP.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">'block'</span></code>: info about matrix blocks</dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'block_nbytes'</span></code>: number of bytes of each block allocated
on the memory. When the number of blocks along row-block (or
column-block) is not a divisor of the matrix size, some
blocks may be smaller, however, this quantity reports the
size of the largest block.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'block_shape'</span></code>: shape of each memory block in array size.
When the number of blocks along row-block (or column-block)
is not a divisor of the matrix size, some blocks may be
smaller, however, this quantity reports the size of the
largest block.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'matrix_blocks'</span></code>: the shape of the grid of blocks that
decomposes the input matrix, which is (<code class="docutils literal notranslate"><span class="pre">num_blocks</span></code>,
<code class="docutils literal notranslate"><span class="pre">num_blocks</span></code>).</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">'scratch'</span></code>: info about scratchpad space (relevant if used)</dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'io_chunk'</span></code>: the size of data chunks for for input/output
data transfer operations between disk and memory. This size
is almost always equal to the size of number of rows/columns
of each block (see <code class="docutils literal notranslate"><span class="pre">block_shape</span></code> above).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'num_scratch_blocks'</span></code>: number of blocks stored to the
scratchpad space. Note that not all memory blocks are
stored, hence, this quantity is smaller than
<code class="docutils literal notranslate"><span class="pre">num_blocks</span> <span class="pre">*</span> <span class="pre">num_blocks</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'scratch_file'</span></code>: the scratch file that was created, and
later deleted after termination of the algorithm. This file
was in the <code class="docutils literal notranslate"><span class="pre">scratch_dir</span></code> and it was a hidden file (for
instance, in UNIX, it has a dot prefix).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'scratch_nbytes'</span></code>: the size of scratchpad file in bytes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'num_block_loads'</span></code>: a counter of the number of times
that blocks were read from disk to memory.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'num_block_stores'</span></code>: a counter of the number of times
that blocks were written from memory to disk.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">'memory'</span></code>: info about memory allocation</dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'alloc_mem'</span></code>: block memory allocated in bytes divided by
<code class="docutils literal notranslate"><span class="pre">mem_unit</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'alloc_mem_peak'</span></code>: block peak memory allocated in bytes
divided by <code class="docutils literal notranslate"><span class="pre">mem_unit</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'total_mem'</span></code>: total memory allocated in bytes divided by
<code class="docutils literal notranslate"><span class="pre">mem_unit</span></code>. This includes the memory of blocks and any
extra memory required by the algorithm.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'total_mem_peak'</span></code>: total peak memory allocated in bytes
divided by <code class="docutils literal notranslate"><span class="pre">mem_unit</span></code>. This includes the memory of blocks
and any extra memory required by the algorithm.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'mem_unit'</span></code>: the unit in which the above memory are
reported with. This is usually the memory (in bytes) of one
block, so it makes the above memory memory sizes relative
to the memory size of one block.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">'solver'</span></code>: info about the solver</dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'version'</span></code>: version of detkit package</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'method'</span></code>: method of computation, such as LU decomposition
, LDL decomposition, or Cholesky decomposition, respectively
for generic, symmetric, or symmetric positive-definite
matrices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'dtype'</span></code>: the data type used during computation (see
<code class="docutils literal notranslate"><span class="pre">'mixed_precision'</span></code> option).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'order'</span></code>: order of array, such as <code class="docutils literal notranslate"><span class="pre">C</span></code> for contiguous
(row-major) ordering or <code class="docutils literal notranslate"><span class="pre">F</span></code> for Fortran (column-major)
ordering during computation.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>RuntimeError</dt><dd><p>Error raised when <code class="docutils literal notranslate"><span class="pre">assume='spd'</span></code> and matrix <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is
not symmetric positive-definite.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="detkit.logdet.html#detkit.logdet" title="detkit.logdet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detkit.logdet</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="detkit.loggdet.html#detkit.loggdet" title="detkit.loggdet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detkit.loggdet</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="detkit.logpdet.html#detkit.logpdet" title="detkit.logpdet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detkit.logpdet</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><strong>How to Limit Memory Usage:</strong></p>
<p>If the whole matrix cannot be loaded on the memory, this function chunks
the matrix into smaller sub-matrices (blocks) and load three or four of
these blocks concurrently to the memory.</p>
<p>For instance, if your matrix size is 100 GB, and your machine has 16 GB
memory, you may need a grid of 5 by 5 blocks (25 blocks), each having
100 GB / 25 = 4 GB in size. Four of these blocks take 16 GB, which can fit
your machine’s memory.</p>
<p>There are two ways to set the memory limit:</p>
<ul class="simple">
<li><p>either directly, by setting <code class="docutils literal notranslate"><span class="pre">max_mem</span></code> argument (such as <code class="docutils literal notranslate"><span class="pre">16GB</span></code> in the
above example),</p></li>
<li><p>or indirectly, by setting <code class="docutils literal notranslate"><span class="pre">num_blocks</span></code> argument (such as 5 in the
above example).</p></li>
</ul>
<p>You only need to set one of these arguments, but not both. However, if you
set <code class="docutils literal notranslate"><span class="pre">max_mem</span></code>, the argument <code class="docutils literal notranslate"><span class="pre">num_blocks</span></code> is ignored, and rather,
recalculated from <code class="docutils literal notranslate"><span class="pre">max_mem</span></code>.</p>
<p><strong>What is Scratch:</strong></p>
<p>When <code class="docutils literal notranslate"><span class="pre">num_blocks</span></code> is 1 or 2 (a grid of 1x1 or 2x2 blocks), all
calculations are performed on the memory, even if the whole input matrix
cannot be fit on the memory (in case of 2x2 blocks)!</p>
<p>However, for larger number of blocks (when <code class="docutils literal notranslate"><span class="pre">num_blocks</span></code> is greater than
2), this function creates a temporary space on your disk to store
the variables during the inner computations. This space (called scratchpad)
is a hidden file created in the <code class="docutils literal notranslate"><span class="pre">scratch_dir</span></code> directory, and will be
automatically removed once this function returns.</p>
<p>If you do not specify <code class="docutils literal notranslate"><span class="pre">scratch_dir</span></code>, the <em>tmp</em> directory in your
operating system (such as <code class="docutils literal notranslate"><span class="pre">/tmp</span></code> in UNIX) will be used.</p>
<p><strong>What is Parallel IO:</strong></p>
<p>This function reads and writes to the scratchpad on your disk. For very
large matrices (and hence, very large blocks) the read/write operations
(io operations) can be time consuming. You can leverage the <code class="docutils literal notranslate"><span class="pre">parallel_io</span></code>
argument to let all CPU threads performing these tasks in parallel.
However, note that, depending on your hardware, your disk may throttle
parallel file operations.</p>
<p><strong>Using Dask:</strong></p>
<p>When using Dask (either if the input array <code class="docutils literal notranslate"><span class="pre">A</span></code> is a Dask array or when
<code class="docutils literal notranslate"><span class="pre">parallel_io='dask'</span></code>), you should call <a class="reference internal" href="#detkit.memdet" title="detkit.memdet"><code class="xref py py-func docutils literal notranslate"><span class="pre">detkit.memdet()</span></code></a> function in
a protected <em>if-clause</em>. See further details at
<a class="reference external" href="https://pytorch.org/docs/stable/notes/windows.html">multiprocessing-error-without-if-clause-protection</a>.</p>
<p><strong>The “diag” and “perm” Output Variables:</strong></p>
<p>In addition to the log-abs-determinant (<code class="docutils literal notranslate"><span class="pre">ld</span></code>) and sign of determinant
(<code class="docutils literal notranslate"><span class="pre">sign</span></code>) variables, this function also returns the <code class="docutils literal notranslate"><span class="pre">diag</span></code> and <code class="docutils literal notranslate"><span class="pre">perm</span></code>
variables. Both of these variables are one-dimensional array of size <cite>n</cite>
(the number of rows or columns of <code class="docutils literal notranslate"><span class="pre">A</span></code>), and can be used to compute the
log-abs-determinants of all leading (principal) sub-matrices of <code class="docutils literal notranslate"><span class="pre">A</span></code>
(or a permutation of <code class="docutils literal notranslate"><span class="pre">A</span></code>) of any size <code class="docutils literal notranslate"><span class="pre">m</span></code> where <code class="docutils literal notranslate"><span class="pre">m</span></code> can be 1 to <cite>n</cite>.
Here is how to use <code class="docutils literal notranslate"><span class="pre">diag</span></code> and <code class="docutils literal notranslate"><span class="pre">perm</span></code>:</p>
<p>Denote the sub-matrix <code class="docutils literal notranslate"><span class="pre">A[:m,</span> <span class="pre">:m]</span></code> as <span class="math notranslate nohighlight">\(\mathbf{M}_{[:m, :m]}\)</span>
and the element <code class="docutils literal notranslate"><span class="pre">diag[i]</span></code> as <span class="math notranslate nohighlight">\(d_i\)</span>. We describe the process for
each of the three cases of generic, symmetric, and symmetric
positive-definite matrices separately.</p>
<ul>
<li><p>For generic and symmetric matrices (if <code class="docutils literal notranslate"><span class="pre">assume</span></code> is set to <code class="docutils literal notranslate"><span class="pre">'gen'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'sym'</span></code>), define the row-permutations of the original matrix as
<span class="math notranslate nohighlight">\(\mathbf{B} = \mathbf{P}^{\intercal} \mathbf{M}\)</span>. This can be
computed by <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">A[perm,</span> <span class="pre">:]</span></code>. Then</p>
<div class="math notranslate nohighlight">
\[\log \vert \mathrm{det}(\mathbf{B}_{[:m, :m]}) \vert =
\sum_{i=1}^{m} \log \vert d_i \vert.\]</div>
</li>
<li><p>For symmetric matrix (if <code class="docutils literal notranslate"><span class="pre">assume</span></code> is set to <code class="docutils literal notranslate"><span class="pre">'sym'</span></code>), define the row
and column permutations of the original matrix as <span class="math notranslate nohighlight">\(\mathbf{B} =
\mathbf{P}^{\intercal} \mathbf{M} \mathbf{P}\)</span>. This can be computed
by <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">A[perm,</span> <span class="pre">:][:,</span> <span class="pre">perm]</span></code>. Then,</p>
<div class="math notranslate nohighlight">
\[\log \vert \mathrm{det}(\mathbf{B}_{[:m, :m]}) \vert =
\sum_{i=1}^{m} \log \vert d_i \vert.\]</div>
</li>
<li><p>For symmetric positive-definite matrix (if <code class="docutils literal notranslate"><span class="pre">assume</span></code> is set to
<code class="docutils literal notranslate"><span class="pre">'spd'</span></code>), no permutation is performed, and  the array <code class="docutils literal notranslate"><span class="pre">perm</span></code>
represents identity matrix (meaning no permutation), and hence, we do not
need to use it. As such,</p>
<div class="math notranslate nohighlight">
\[\log \vert \mathrm{det}(\mathbf{M}_{[:m, :m]}) \vert =
2 \sum_{i=1}^{m} \log \vert d_i \vert.\]</div>
</li>
</ul>
<p>The output variable <code class="docutils literal notranslate"><span class="pre">ld</span></code> can also be retrieved from <code class="docutils literal notranslate"><span class="pre">diag</span></code> when
<span class="math notranslate nohighlight">\(m = n\)</span> in the above formulations.</p>
<p>Note that computing <code class="docutils literal notranslate"><span class="pre">diag</span></code> and <code class="docutils literal notranslate"><span class="pre">perm</span></code> are by-products of the algorithms
for free and they do not require any additional cost.</p>
<p><strong>Counting FLOPs:</strong></p>
<p>FLOPs are counted when <code class="docutils literal notranslate"><span class="pre">flops=True</span></code> and <code class="docutils literal notranslate"><span class="pre">return_info=True</span></code> are set.
FLOPs counts are stored at <code class="docutils literal notranslate"><span class="pre">info['process']['flops']</span></code>.</p>
<p>To compute FLOPs, you should install <a class="reference internal" href="../install/dependencies.html#perf-tool"><span class="std std-ref">Perf Tool</span></a> and
grant necessary permissions to the kernel. Computing FLOPs with Perf Tool
can only be done on Linux machines.</p>
<p>FLOPS are computed by multiplying hardware instruction counts (which can be
found at <code class="docutils literal notranslate"><span class="pre">info['process']['hw_inst_count']</span></code> and instructions per FLOP
(which can be found at <code class="docutils literal notranslate"><span class="pre">info['process']['inst_per_flop']</span></code>).</p>
<p>Single instruction, multiple data (SIMD) factor indicates the number of
FLOPS per one hardware instruction count, and this is estimated by
<a class="reference internal" href="detkit.get_instructions_per_flop.html#detkit.get_instructions_per_flop" title="detkit.get_instructions_per_flop"><code class="xref py py-func docutils literal notranslate"><span class="pre">detkit.get_instructions_per_flop()</span></code></a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rcb8eaaf14d1c-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Siavash Ameli, Chris van der Heide, Liam Hodgkinson, Fred Roosta,
Michael W. Mahoney (2025). Determinant Estimation under Memory
Constraints and Neural Scaling Law (<em>under review</em>)</p>
</div>
</div>
<p class="rubric">Examples</p>
<p>In this example, we generate a random matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, and for test purposes,
we store this matrix on the disk as a <cite>zarr</cite> array <code class="docutils literal notranslate"><span class="pre">z</span></code>. You can either
pass <code class="docutils literal notranslate"><span class="pre">A</span></code> or <code class="docutils literal notranslate"><span class="pre">z</span></code> to <a class="reference internal" href="#detkit.memdet" title="detkit.memdet"><code class="xref py py-func docutils literal notranslate"><span class="pre">detkit.memdet()</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a symmetric matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">A</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Store matrix as a zarr array on disk (optional)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">zarr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z_path</span> <span class="o">=</span> <span class="s1">&#39;matrix_file.zarr&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">z_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">A</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute log-determinant while limiting memory to 500 MB</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">detkit</span><span class="w"> </span><span class="kn">import</span> <span class="n">memdet</span>
<span class="hll"><span class="gp">&gt;&gt;&gt; </span><span class="n">ld</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">memdet</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">max_mem</span><span class="o">=</span><span class="s1">&#39;500MB&#39;</span><span class="p">,</span>
</span><span class="hll"><span class="gp">... </span>                                    <span class="n">assume</span><span class="o">=</span><span class="s1">&#39;sym&#39;</span><span class="p">,</span>
</span><span class="hll"><span class="gp">... </span>                                    <span class="n">parallel_io</span><span class="o">=</span><span class="s1">&#39;tensorstore&#39;</span><span class="p">,</span>
</span><span class="hll"><span class="gp">... </span>                                    <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># logarithm of absolute value of determinant</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ld</span><span class="p">)</span>
<span class="go">82104.567748</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># sign of determinant</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sign</span><span class="p">)</span>
<span class="go">-1</span>
</pre></div>
</div>
<p>By setting <code class="docutils literal notranslate"><span class="pre">verbose=True</span></code>, a detailed log is printed during the
computation, as shown in the screenshot below.</p>
<img alt="../_images/memdet_verbose.png" class="custom-dark align-center" src="../_images/memdet_verbose.png" />
<p>The above logs illustrate how the matrix is processed. For example, due to
the memory limit of 500 MB, a matrix of size 762.9 MB is decomposed into
smaller blocks (a grid of 3 by 3 blocks), where each block is 84.8 MB. At
any time, only four of these blocks are concurrently loaded into memory:
blocks <em>A11</em>, <em>A12</em>, <em>A21</em>, and <em>A22</em>. The allocated size of each block is
shown.</p>
<p>In the above, the computation was performed in 7 steps. The number of steps
vary depending the number of blocks. Each step may involve:</p>
<ul class="simple">
<li><p>Loading a block from disk to memory (<cite>loading blk</cite>)</p></li>
<li><p>Storing a block from memory back to disk (<cite>storing blk</cite>)</p></li>
<li><p>Performing LU, LDL, or Cholesky decomposition (e.g. <cite>ldl decompo</cite>)</p></li>
<li><p>Solving an upper triangular system of equations (<cite>solve uptri</cite>)</p></li>
<li><p>Solving a lower triangular system of equations (<cite>solve lotri</cite>)</p></li>
<li><p>Computing the Schur complement (<cite>schur compl</cite>)</p></li>
</ul>
<p>For each task, the proceeding columns in the verbose prints are as follows:</p>
<ul class="simple">
<li><p><em>time</em>: CPU process time</p></li>
<li><p><em>cpu</em>: CPU utilization percentage (for all CPU threads combined)</p></li>
<li><p><em>alloc</em>: Peak memory allocation during the task</p></li>
<li><p><em>read</em>: Data read from scratchpad on disk</p></li>
<li><p><em>write</em>: Data written to scratchpad on disk</p></li>
</ul>
<p>Note that an efficient implementation should not allocate any new memory
during any of the above tasks during the computation. The only memory
allocation should be the creation of the blocks at the beginning. As seen
in the screenshot above, all memory allocations (on the order of KB) are
negligible compared to the size of a block (on the order of MB), indicating
that no new array is created.</p>
<p>The above code also returns the <code class="docutils literal notranslate"><span class="pre">info</span></code> variable by setting
<code class="docutils literal notranslate"><span class="pre">return_info=True</span></code>. Here is a pretty-print of <code class="docutils literal notranslate"><span class="pre">info</span></code> dictionary:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Print info results</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pprint</span><span class="w"> </span><span class="kn">import</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
</pre></div>
</div>
<p>which gives the following output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s1">&#39;block&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;block_nbytes&#39;</span><span class="p">:</span> <span class="mi">88924448</span><span class="p">,</span>
        <span class="s1">&#39;block_shape&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">3334</span><span class="p">,</span> <span class="mi">3334</span><span class="p">),</span>
        <span class="s1">&#39;matrix_blocks&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="s1">&#39;matrix&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;assume&#39;</span><span class="p">:</span> <span class="s1">&#39;sym&#39;</span><span class="p">,</span>
        <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
        <span class="s1">&#39;matrix_shape&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">),</span>
        <span class="s1">&#39;triangle&#39;</span><span class="p">:</span> <span class="kc">None</span>
    <span class="p">},</span>
    <span class="s1">&#39;memory&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;alloc_mem&#39;</span><span class="p">:</span> <span class="mf">4.003514331626776</span><span class="p">,</span>
        <span class="s1">&#39;alloc_mem_peak&#39;</span><span class="p">:</span> <span class="mf">4.004212868434112</span><span class="p">,</span>
        <span class="s1">&#39;mem_unit&#39;</span><span class="p">:</span> <span class="s1">&#39;88924448 bytes&#39;</span><span class="p">,</span>
        <span class="s1">&#39;total_mem&#39;</span><span class="p">:</span> <span class="mf">0.0009245601389620096</span><span class="p">,</span>
        <span class="s1">&#39;total_mem_peak&#39;</span><span class="p">:</span> <span class="mf">0.0027315772598329765</span>
    <span class="p">},</span>
    <span class="s1">&#39;process&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;load_proc_time&#39;</span><span class="p">:</span> <span class="mf">4.354914859999929</span><span class="p">,</span>
         <span class="s1">&#39;load_wall_time&#39;</span><span class="p">:</span> <span class="mf">2.3955368995666504</span><span class="p">,</span>
         <span class="s1">&#39;num_proc&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
         <span class="s1">&#39;processor&#39;</span><span class="p">:</span> <span class="s1">&#39; Intel(R) Core(TM) i7-4770K CPU @ 3.50GHz&#39;</span><span class="p">,</span>
         <span class="s1">&#39;store_proc_time&#39;</span><span class="p">:</span> <span class="mf">1.6077849289999904</span><span class="p">,</span>
         <span class="s1">&#39;store_wall_time&#39;</span><span class="p">:</span> <span class="mf">1.626847743988037</span><span class="p">,</span>
         <span class="s1">&#39;tot_proc_time&#39;</span><span class="p">:</span> <span class="mf">600.250950974</span><span class="p">,</span>
         <span class="s1">&#39;tot_wall_time&#39;</span><span class="p">:</span> <span class="mf">115.73805451393127</span>
    <span class="p">},</span>
    <span class="s1">&#39;scratch&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;io_chunk&#39;</span><span class="p">:</span> <span class="mi">3334</span><span class="p">,</span>
         <span class="s1">&#39;num_block_loads&#39;</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span>
         <span class="s1">&#39;num_block_stores&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
         <span class="s1">&#39;num_scratch_blocks&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
         <span class="s1">&#39;scratch_file&#39;</span><span class="p">:</span> <span class="s1">&#39;/tmp/.detkit-memdet-va1k6eio.zarr&#39;</span><span class="p">,</span>
         <span class="s1">&#39;scratch_nbytes&#39;</span><span class="p">:</span> <span class="mi">0</span>
    <span class="p">},</span>
    <span class="s1">&#39;solver&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
        <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;ldl decomposition&#39;</span><span class="p">,</span>
        <span class="s1">&#39;order&#39;</span><span class="p">:</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span>
        <span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="s1">&#39;0.6.1&#39;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Working with “diag” and “perm” outputs:</strong></p>
<p>The following shows how to use <code class="docutils literal notranslate"><span class="pre">diag</span></code> and <code class="docutils literal notranslate"><span class="pre">perm</span></code> for a <strong>generic</strong>
matrix:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a symmetric matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute log-determinant for generic matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">detkit</span><span class="w"> </span><span class="kn">import</span> <span class="n">memdet</span>
<span class="hll"><span class="gp">&gt;&gt;&gt; </span><span class="n">ld</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">perm</span> <span class="o">=</span> <span class="n">memdet</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">assume</span><span class="o">=</span><span class="s1">&#39;gen&#39;</span><span class="p">,</span> <span class="n">num_blocks</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute log-determinants of all sub-matrices using diag and perm</span>
<span class="hll"><span class="gp">&gt;&gt;&gt; </span><span class="n">lds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diag</span><span class="p">)))</span>
</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The above lds array are the log-determinants of the principal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># sub-matrices of the following matrix</span>
<span class="hll"><span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">perm</span><span class="p">,</span> <span class="p">:]</span>
</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Directly compute logdet of sub-matrices of B (for comparison)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">detkit</span><span class="w"> </span><span class="kn">import</span> <span class="n">logdet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lds2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="n">lds2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">logdet</span><span class="p">(</span><span class="n">B</span><span class="p">[:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The two arrays lds and lds2 should be identical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">lds</span><span class="p">,</span> <span class="n">lds2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>For <strong>symmetric</strong> matrix, the matrix <code class="docutils literal notranslate"><span class="pre">B</span></code> in the above should be defined
as <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">A[perm,</span> <span class="pre">:][:,</span> <span class="pre">perm]</span></code>. Here is the full code for symmetric matrix:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a symmetric matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># symmetric matrix</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute log-determinant for symmetric matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">detkit</span><span class="w"> </span><span class="kn">import</span> <span class="n">memdet</span>
<span class="hll"><span class="gp">&gt;&gt;&gt; </span><span class="n">ld</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">perm</span> <span class="o">=</span> <span class="n">memdet</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">assume</span><span class="o">=</span><span class="s1">&#39;sym&#39;</span><span class="p">,</span> <span class="n">num_blocks</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute log-determinants and sign of determinants of all</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># sub-matrices using diag and perm</span>
<span class="hll"><span class="gp">&gt;&gt;&gt; </span><span class="n">lds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diag</span><span class="p">)))</span>
</span><span class="hll"><span class="gp">&gt;&gt;&gt; </span><span class="n">signs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">diag</span><span class="p">))</span>
</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The above lds array are the log-determinants of the principal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># sub-matrices of the following matrix</span>
<span class="hll"><span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">perm</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">perm</span><span class="p">]</span>
</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Directly compute logdet of sub-matrices of B (for comparison)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">detkit</span><span class="w"> </span><span class="kn">import</span> <span class="n">logdet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lds2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signs2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="n">lds2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">signs2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">logdet</span><span class="p">(</span><span class="n">B</span><span class="p">[:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The two arrays lds and lds2 should be identical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">lds</span><span class="p">,</span> <span class="n">lds2</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The two arrays signs and signs2 should be identical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">signs</span><span class="p">,</span> <span class="n">signs2</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>For <strong>symmetric positive-definite</strong> matrices, the <code class="docutils literal notranslate"><span class="pre">perm</span></code> output is not
needed. Here an example on how to use <code class="docutils literal notranslate"><span class="pre">diag</span></code>. Note that for these
matrices, the sign of determinant is always <code class="docutils literal notranslate"><span class="pre">+1</span></code> as the determinant is
always positive, so we do not check it here.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a symmetric matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># symmetric positive-definite matrix</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute log-determinant for symmetric positive-definite matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">detkit</span><span class="w"> </span><span class="kn">import</span> <span class="n">memdet</span>
<span class="hll"><span class="gp">&gt;&gt;&gt; </span><span class="n">ld</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">perm</span> <span class="o">=</span> <span class="n">memdet</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">assume</span><span class="o">=</span><span class="s1">&#39;spd&#39;</span><span class="p">,</span> <span class="n">num_blocks</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute log-determinants of all sub-matrices using diag.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Note, here, the multiplication factor 2.0 is needed.</span>
<span class="hll"><span class="gp">&gt;&gt;&gt; </span><span class="n">lds</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diag</span><span class="p">)))</span>
</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Directly compute logdet of sub-matrices of A (for comparison)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">detkit</span><span class="w"> </span><span class="kn">import</span> <span class="n">logdet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lds2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="n">lds2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">logdet</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The two arrays lds and lds2 should be identical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">lds</span><span class="p">,</span> <span class="n">lds2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</section>


              </article>
              

              
              <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
  <a class='left-prev' id="prev-link" href="detkit.logpdet.html" title="previous page">
      <i class="fas fa-angle-left"></i>
      <div class="prev-next-info">
          <p class="prev-next-subtitle">previous</p>
          <p class="prev-next-title">logpdet</p>
      </div>
  </a>
  <a class='right-next' id="next-link" href="detkit.FitLogdet.html" title="next page">
  <div class="prev-next-info">
      <p class="prev-next-subtitle">next</p>
      <p class="prev-next-title">detkit.FitLogdet</p>
  </div>
  <i class="fas fa-angle-right"></i>
  </a>
</div>
              </footer>
              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>


    <!-- Adobe Embed API -->
    
    <script src="https://documentcloud.adobe.com/view-sdk/main.js"></script>


  </body>
</html>